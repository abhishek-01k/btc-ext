/*! For license information please see 904.js.LICENSE.txt */
"use strict";(self.webpackChunkreactchromeext=self.webpackChunkreactchromeext||[]).push([[904],{7557:(e,t)=>{function r(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function n(e){if("boolean"!=typeof e)throw new Error(`boolean expected, not ${e}`)}function o(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function i(e,...t){if(!o(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function s(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(e.outputLen),r(e.blockLen)}function a(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function c(e,t){i(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}Object.defineProperty(t,"__esModule",{value:!0}),t.output=t.exists=t.hash=t.bytes=t.bool=t.number=t.isBytes=void 0,t.number=r,t.bool=n,t.isBytes=o,t.bytes=i,t.hash=s,t.exists=a,t.output=c;const u={number:r,bool:n,bytes:i,hash:s,exists:a,output:c};t.default=u},7202:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.HashMD=t.Maj=t.Chi=void 0;const n=r(7557),o=r(9175);t.Chi=(e,t,r)=>e&t^~e&r,t.Maj=(e,t,r)=>e&t^e&r^t&r;class i extends o.Hash{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=(0,o.createView)(this.buffer)}update(e){(0,n.exists)(this);const{view:t,buffer:r,blockLen:i}=this,s=(e=(0,o.toBytes)(e)).length;for(let n=0;n<s;){const a=Math.min(i-this.pos,s-n);if(a!==i)r.set(e.subarray(n,n+a),this.pos),this.pos+=a,n+=a,this.pos===i&&(this.process(t,0),this.pos=0);else{const t=(0,o.createView)(e);for(;i<=s-n;n+=i)this.process(t,n)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){(0,n.exists)(this),(0,n.output)(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:i,isLE:s}=this;let{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>i-a&&(this.process(r,0),a=0);for(let e=a;e<i;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?4:0,u=n?0:4;e.setUint32(t+c,s,n),e.setUint32(t+u,a,n)}(r,i-8,BigInt(8*this.length),s),this.process(r,0);const c=(0,o.createView)(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=u/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<h;e++)c.setUint32(4*e,f[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return e.length=n,e.pos=s,e.finished=o,e.destroyed=i,n%t&&e.buffer.set(r),e}}t.HashMD=i},5145:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.crypto=void 0,t.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},9615:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.hmac=t.HMAC=void 0;const n=r(7557),o=r(9175);class i extends o.Hash{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,(0,n.hash)(e);const r=(0,o.toBytes)(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?e.create().update(r).digest():r);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),s.fill(0)}update(e){return(0,n.exists)(this),this.iHash.update(e),this}digestInto(e){(0,n.exists)(this),(0,n.bytes)(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:o,blockLen:i,outputLen:s}=this;return e.finished=n,e.destroyed=o,e.blockLen=i,e.outputLen=s,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}t.HMAC=i,t.hmac=(e,t,r)=>new i(e,t).update(r).digest(),t.hmac.create=(e,t)=>new i(e,t)},2623:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sha224=t.sha256=void 0;const n=r(7202),o=r(9175),i=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),s=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),a=new Uint32Array(64);class c extends n.HashMD{constructor(){super(64,32,8,!1),this.A=0|s[0],this.B=0|s[1],this.C=0|s[2],this.D=0|s[3],this.E=0|s[4],this.F=0|s[5],this.G=0|s[6],this.H=0|s[7]}get(){const{A:e,B:t,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[e,t,r,n,o,i,s,a]}set(e,t,r,n,o,i,s,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)a[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=a[e-15],r=a[e-2],n=(0,o.rotr)(t,7)^(0,o.rotr)(t,18)^t>>>3,i=(0,o.rotr)(r,17)^(0,o.rotr)(r,19)^r>>>10;a[e]=i+a[e-7]+n+a[e-16]|0}let{A:r,B:s,C:c,D:u,E:h,F:f,G:d,H:l}=this;for(let e=0;e<64;e++){const t=l+((0,o.rotr)(h,6)^(0,o.rotr)(h,11)^(0,o.rotr)(h,25))+(0,n.Chi)(h,f,d)+i[e]+a[e]|0,y=((0,o.rotr)(r,2)^(0,o.rotr)(r,13)^(0,o.rotr)(r,22))+(0,n.Maj)(r,s,c)|0;l=d,d=f,f=h,h=u+t|0,u=c,c=s,s=r,r=t+y|0}r=r+this.A|0,s=s+this.B|0,c=c+this.C|0,u=u+this.D|0,h=h+this.E|0,f=f+this.F|0,d=d+this.G|0,l=l+this.H|0,this.set(r,s,c,u,h,f,d,l)}roundClean(){a.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class u extends c{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}t.sha256=(0,o.wrapConstructor)((()=>new c)),t.sha224=(0,o.wrapConstructor)((()=>new u))},9175:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.randomBytes=t.wrapXOFConstructorWithOpts=t.wrapConstructorWithOpts=t.wrapConstructor=t.checkOpts=t.Hash=t.concatBytes=t.toBytes=t.utf8ToBytes=t.asyncLoop=t.nextTick=t.hexToBytes=t.bytesToHex=t.byteSwap32=t.byteSwapIfBE=t.byteSwap=t.isLE=t.rotl=t.rotr=t.createView=t.u32=t.u8=t.isBytes=void 0;const n=r(5145),o=r(7557);t.isBytes=function(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name},t.u8=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),t.u32=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),t.createView=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),t.rotr=(e,t)=>e<<32-t|e>>>t,t.rotl=(e,t)=>e<<t|e>>>32-t>>>0,t.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],t.byteSwap=e=>e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255,t.byteSwapIfBE=t.isLE?e=>e:e=>(0,t.byteSwap)(e),t.byteSwap32=function(e){for(let r=0;r<e.length;r++)e[r]=(0,t.byteSwap)(e[r])};const i=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));t.bytesToHex=function(e){(0,o.bytes)(e);let t="";for(let r=0;r<e.length;r++)t+=i[e[r]];return t};const s=48,a=57,c=65,u=70,h=97,f=102;function d(e){return e>=s&&e<=a?e-s:e>=c&&e<=u?e-(c-10):e>=h&&e<=f?e-(h-10):void 0}function l(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function y(e){return"string"==typeof e&&(e=l(e)),(0,o.bytes)(e),e}t.hexToBytes=function(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,o=0;t<r;t++,o+=2){const r=d(e.charCodeAt(o)),i=d(e.charCodeAt(o+1));if(void 0===r||void 0===i){const t=e[o]+e[o+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+o)}n[t]=16*r+i}return n},t.nextTick=async()=>{},t.asyncLoop=async function(e,r,n){let o=Date.now();for(let i=0;i<e;i++){n(i);const e=Date.now()-o;e>=0&&e<r||(await(0,t.nextTick)(),o+=e)}},t.utf8ToBytes=l,t.toBytes=y,t.concatBytes=function(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];(0,o.bytes)(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const o=e[t];r.set(o,n),n+=o.length}return r},t.Hash=class{clone(){return this._cloneInto()}};const p={}.toString;t.checkOpts=function(e,t){if(void 0!==t&&"[object Object]"!==p.call(t))throw new Error("Options should be object or undefined");return Object.assign(e,t)},t.wrapConstructor=function(e){const t=t=>e().update(y(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t},t.wrapConstructorWithOpts=function(e){const t=(t,r)=>e(r).update(y(t)).digest(),r=e({});return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=t=>e(t),t},t.wrapXOFConstructorWithOpts=function(e){const t=(t,r)=>e(r).update(y(t)).digest(),r=e({});return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=t=>e(t),t},t.randomBytes=function(e=32){if(n.crypto&&"function"==typeof n.crypto.getRandomValues)return n.crypto.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}},9598:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.utils=t.schnorr=t.verify=t.signSync=t.sign=t.getSharedSecret=t.recoverPublicKey=t.getPublicKey=t.Signature=t.Point=t.CURVE=void 0;const n=r(4923),o=BigInt(0),i=BigInt(1),s=BigInt(2),a=BigInt(3),c=BigInt(8),u=Object.freeze({a:o,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:i,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});t.CURVE=u;const h=(e,t)=>(e+t/s)/t,f={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(e){const{n:t}=u,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-i*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,a=BigInt("0x100000000000000000000000000000000"),c=h(s*e,t),f=h(-n*e,t);let d=$(e-c*r-f*o,t),l=$(-c*n-f*s,t);const y=d>a,p=l>a;if(y&&(d=t-d),p&&(l=t-l),d>a||l>a)throw new Error("splitScalarEndo: Endomorphism failed, k="+e);return{k1neg:y,k1:d,k2neg:p,k2:l}}},d=32,l=32,y=d+1,p=2*d+1;function g(e){const{a:t,b:r}=u,n=$(e*e),o=$(n*e);return $(o+t*e+r)}const w=u.a===o;class b extends Error{constructor(e){super(e)}}function v(e){if(!(e instanceof m))throw new TypeError("JacobianPoint expected")}class m{constructor(e,t,r){this.x=e,this.y=t,this.z=r}static fromAffine(e){if(!(e instanceof S))throw new TypeError("JacobianPoint#fromAffine: expected Point");return e.equals(S.ZERO)?m.ZERO:new m(e.x,e.y,i)}static toAffineBatch(e){const t=function(e,t=u.P){const r=new Array(e.length),n=D(e.reduce(((e,n,i)=>n===o?e:(r[i]=e,$(e*n,t))),i),t);return e.reduceRight(((e,n,i)=>n===o?e:(r[i]=$(e*r[i],t),$(e*n,t))),n),r}(e.map((e=>e.z)));return e.map(((e,r)=>e.toAffine(t[r])))}static normalizeZ(e){return m.toAffineBatch(e).map(m.fromAffine)}equals(e){v(e);const{x:t,y:r,z:n}=this,{x:o,y:i,z:s}=e,a=$(n*n),c=$(s*s),u=$(t*c),h=$(o*a),f=$($(r*s)*c),d=$($(i*n)*a);return u===h&&f===d}negate(){return new m(this.x,$(-this.y),this.z)}double(){const{x:e,y:t,z:r}=this,n=$(e*e),o=$(t*t),i=$(o*o),u=e+o,h=$(s*($(u*u)-n-i)),f=$(a*n),d=$(f*f),l=$(d-s*h),y=$(f*(h-l)-c*i),p=$(s*t*r);return new m(l,y,p)}add(e){v(e);const{x:t,y:r,z:n}=this,{x:i,y:a,z:c}=e;if(i===o||a===o)return this;if(t===o||r===o)return e;const u=$(n*n),h=$(c*c),f=$(t*h),d=$(i*u),l=$($(r*c)*h),y=$($(a*n)*u),p=$(d-f),g=$(y-l);if(p===o)return g===o?this.double():m.ZERO;const w=$(p*p),b=$(p*w),E=$(f*w),x=$(g*g-b-s*E),S=$(g*(E-x)-l*b),P=$(n*c*p);return new m(x,S,P)}subtract(e){return this.add(e.negate())}multiplyUnsafe(e){const t=m.ZERO;if("bigint"==typeof e&&e===o)return t;let r=R(e);if(r===i)return this;if(!w){let e=t,n=this;for(;r>o;)r&i&&(e=e.add(n)),n=n.double(),r>>=i;return e}let{k1neg:n,k1:s,k2neg:a,k2:c}=f.splitScalar(r),u=t,h=t,d=this;for(;s>o||c>o;)s&i&&(u=u.add(d)),c&i&&(h=h.add(d)),d=d.double(),s>>=i,c>>=i;return n&&(u=u.negate()),a&&(h=h.negate()),h=new m($(h.x*f.beta),h.y,h.z),u.add(h)}precomputeWindow(e){const t=w?128/e+1:256/e+1,r=[];let n=this,o=n;for(let i=0;i<t;i++){o=n,r.push(o);for(let t=1;t<2**(e-1);t++)o=o.add(n),r.push(o);n=o.double()}return r}wNAF(e,t){!t&&this.equals(m.BASE)&&(t=S.BASE);const r=t&&t._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=t&&x.get(t);n||(n=this.precomputeWindow(r),t&&1!==r&&(n=m.normalizeZ(n),x.set(t,n)));let o=m.ZERO,s=m.BASE;const a=1+(w?128/r:256/r),c=2**(r-1),u=BigInt(2**r-1),h=2**r,f=BigInt(r);for(let t=0;t<a;t++){const r=t*c;let a=Number(e&u);e>>=f,a>c&&(a-=h,e+=i);const d=r,l=r+Math.abs(a)-1,y=t%2!=0,p=a<0;0===a?s=s.add(E(y,n[d])):o=o.add(E(p,n[l]))}return{p:o,f:s}}multiply(e,t){let r,n,o=R(e);if(w){const{k1neg:e,k1:i,k2neg:s,k2:a}=f.splitScalar(o);let{p:c,f:u}=this.wNAF(i,t),{p:h,f:d}=this.wNAF(a,t);c=E(e,c),h=E(s,h),h=new m($(h.x*f.beta),h.y,h.z),r=c.add(h),n=u.add(d)}else{const{p:e,f:i}=this.wNAF(o,t);r=e,n=i}return m.normalizeZ([r,n])[0]}toAffine(e){const{x:t,y:r,z:n}=this,o=this.equals(m.ZERO);null==e&&(e=o?c:D(n));const s=e,a=$(s*s),u=$(a*s),h=$(t*a),f=$(r*u),d=$(n*s);if(o)return S.ZERO;if(d!==i)throw new Error("invZ was invalid");return new S(h,f)}}function E(e,t){const r=t.negate();return e?r:t}m.BASE=new m(u.Gx,u.Gy,i),m.ZERO=new m(o,i,o);const x=new WeakMap;class S{constructor(e,t){this.x=e,this.y=t}_setWindowSize(e){this._WINDOW_SIZE=e,x.delete(this)}hasEvenY(){return this.y%s===o}static fromCompressedHex(e){const t=32===e.length,r=M(t?e:e.subarray(1));if(!W(r))throw new Error("Point is not on curve");let n=function(e){const{P:t}=u,r=BigInt(6),n=BigInt(11),o=BigInt(22),i=BigInt(23),c=BigInt(44),h=BigInt(88),f=e*e*e%t,d=f*f*e%t,l=N(d,a)*d%t,y=N(l,a)*d%t,p=N(y,s)*f%t,g=N(p,n)*p%t,w=N(g,o)*g%t,b=N(w,c)*w%t,v=N(b,h)*b%t,m=N(v,c)*w%t,E=N(m,a)*d%t,x=N(E,i)*g%t,S=N(x,r)*f%t,P=N(S,s);if(P*P%t!==e)throw new Error("Cannot find square root");return P}(g(r));const o=(n&i)===i;t?o&&(n=$(-n)):!(1&~e[0])!==o&&(n=$(-n));const c=new S(r,n);return c.assertValidity(),c}static fromUncompressedHex(e){const t=M(e.subarray(1,d+1)),r=M(e.subarray(d+1,2*d+1)),n=new S(t,r);return n.assertValidity(),n}static fromHex(e){const t=L(e),r=t.length,n=t[0];if(r===d)return this.fromCompressedHex(t);if(r===y&&(2===n||3===n))return this.fromCompressedHex(t);if(r===p&&4===n)return this.fromUncompressedHex(t);throw new Error(`Point.fromHex: received invalid point. Expected 32-${y} compressed bytes or ${p} uncompressed bytes, not ${r}`)}static fromPrivateKey(e){return S.BASE.multiply(Z(e))}static fromSignature(e,t,r){const{r:n,s:o}=X(t);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");const i=q(L(e)),{n:s}=u,a=2===r||3===r?n+s:n,c=D(a,s),h=$(-i*c,s),f=$(o*c,s),d=1&r?"03":"02",l=S.fromHex(d+C(a)),y=S.BASE.multiplyAndAddUnsafe(l,h,f);if(!y)throw new Error("Cannot recover signature: point at infinify");return y.assertValidity(),y}toRawBytes(e=!1){return U(this.toHex(e))}toHex(e=!1){const t=C(this.x);return e?`${this.hasEvenY()?"02":"03"}${t}`:`04${t}${C(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const e="Point is not on elliptic curve",{x:t,y:r}=this;if(!W(t)||!W(r))throw new Error(e);const n=$(r*r);if($(n-g(t))!==o)throw new Error(e)}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new S(this.x,$(-this.y))}double(){return m.fromAffine(this).double().toAffine()}add(e){return m.fromAffine(this).add(m.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return m.fromAffine(this).multiply(e,this).toAffine()}multiplyAndAddUnsafe(e,t,r){const n=m.fromAffine(this),s=t===o||t===i||this!==S.BASE?n.multiplyUnsafe(t):n.multiply(t),a=m.fromAffine(e).multiplyUnsafe(r),c=s.add(a);return c.equals(m.ZERO)?void 0:c.toAffine()}}function P(e){return Number.parseInt(e[0],16)>=8?"00"+e:e}function _(e){if(e.length<2||2!==e[0])throw new Error(`Invalid signature integer tag: ${T(e)}`);const t=e[1],r=e.subarray(2,t+2);if(!t||r.length!==t)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:M(r),left:e.subarray(t+2)}}t.Point=S,S.BASE=new S(u.Gx,u.Gy),S.ZERO=new S(o,o);class A{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromCompact(e){const t=e instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof e&&!t)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=t?T(e):e;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new A(I(n.slice(0,64)),I(n.slice(64,128)))}static fromDER(e){const t=e instanceof Uint8Array;if("string"!=typeof e&&!t)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r,s:n}=function(e){if(e.length<2||48!=e[0])throw new Error(`Invalid signature tag: ${T(e)}`);if(e[1]!==e.length-2)throw new Error("Invalid signature: incorrect length");const{data:t,left:r}=_(e.subarray(2)),{data:n,left:o}=_(r);if(o.length)throw new Error(`Invalid signature: left bytes after parsing: ${T(o)}`);return{r:t,s:n}}(t?e:U(e));return new A(r,n)}static fromHex(e){return this.fromDER(e)}assertValidity(){const{r:e,s:t}=this;if(!V(e))throw new Error("Invalid Signature: r must be 0 < r < n");if(!V(t))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const e=u.n>>i;return this.s>e}normalizeS(){return this.hasHighS()?new A(this.r,$(-this.s,u.n)):this}toDERRawBytes(){return U(this.toDERHex())}toDERHex(){const e=P(H(this.s)),t=P(H(this.r)),r=e.length/2,n=t.length/2,o=H(r),i=H(n);return`30${H(n+r+4)}02${i}${t}02${o}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return U(this.toCompactHex())}toCompactHex(){return C(this.r)+C(this.s)}}function O(...e){if(!e.every((e=>e instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===e.length)return e[0];const t=e.reduce(((e,t)=>e+t.length),0),r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const o=e[t];r.set(o,n),n+=o.length}return r}t.Signature=A;const B=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function T(e){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");let t="";for(let r=0;r<e.length;r++)t+=B[e[r]];return t}const j=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function C(e){if("bigint"!=typeof e)throw new Error("Expected bigint");if(!(o<=e&&e<j))throw new Error("Expected number 0 <= n < 2^256");return e.toString(16).padStart(64,"0")}function k(e){const t=U(C(e));if(32!==t.length)throw new Error("Error: expected 32 bytes");return t}function H(e){const t=e.toString(16);return 1&t.length?`0${t}`:t}function I(e){if("string"!=typeof e)throw new TypeError("hexToNumber: expected string, got "+typeof e);return BigInt(`0x${e}`)}function U(e){if("string"!=typeof e)throw new TypeError("hexToBytes: expected string, got "+typeof e);if(e.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+e.length);const t=new Uint8Array(e.length/2);for(let r=0;r<t.length;r++){const n=2*r,o=e.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");t[r]=i}return t}function M(e){return I(T(e))}function L(e){return e instanceof Uint8Array?Uint8Array.from(e):U(e)}function R(e){if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)return BigInt(e);if("bigint"==typeof e&&V(e))return e;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function $(e,t=u.P){const r=e%t;return r>=o?r:t+r}function N(e,t){const{P:r}=u;let n=e;for(;t-- >o;)n*=n,n%=r;return n}function D(e,t=u.P){if(e===o||t<=o)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=$(e,t),n=t,s=o,a=i,c=i,h=o;for(;r!==o;){const e=n/r,t=n%r,o=s-c*e,i=a-h*e;n=r,r=t,s=c,a=h,c=o,h=i}if(n!==i)throw new Error("invert: does not exist");return $(s,t)}function q(e,t=!1){const r=function(e){const t=8*e.length-8*l,r=M(e);return t>0?r>>BigInt(t):r}(e);if(t)return r;const{n}=u;return r>=n?r-n:r}let z,K;class F{constructor(e,t){if(this.hashLen=e,this.qByteLen=t,"number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(e).fill(1),this.k=new Uint8Array(e).fill(0),this.counter=0}hmac(...e){return t.utils.hmacSha256(this.k,...e)}hmacSync(...e){return K(this.k,...e)}checkSync(){if("function"!=typeof K)throw new b("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(e=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),e),this.v=await this.hmac(this.v),0!==e.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),e),this.v=await this.hmac(this.v))}reseedSync(e=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),e),this.v=this.hmacSync(this.v),0!==e.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),e),this.v=this.hmacSync(this.v))}async generate(){this.incr();let e=0;const t=[];for(;e<this.qByteLen;){this.v=await this.hmac(this.v);const r=this.v.slice();t.push(r),e+=this.v.length}return O(...t)}generateSync(){this.checkSync(),this.incr();let e=0;const t=[];for(;e<this.qByteLen;){this.v=this.hmacSync(this.v);const r=this.v.slice();t.push(r),e+=this.v.length}return O(...t)}}function V(e){return o<e&&e<u.n}function W(e){return o<e&&e<u.P}function J(e,t,r,n=!0){const{n:s}=u,a=q(e,!0);if(!V(a))return;const c=D(a,s),h=S.BASE.multiply(a),f=$(h.x,s);if(f===o)return;const d=$(c*$(t+r*f,s),s);if(d===o)return;let l=new A(f,d),y=(h.x===l.r?0:2)|Number(h.y&i);return n&&l.hasHighS()&&(l=l.normalizeS(),y^=1),{sig:l,recovery:y}}function Z(e){let t;if("bigint"==typeof e)t=e;else if("number"==typeof e&&Number.isSafeInteger(e)&&e>0)t=BigInt(e);else if("string"==typeof e){if(e.length!==2*l)throw new Error("Expected 32 bytes of private key");t=I(e)}else{if(!(e instanceof Uint8Array))throw new TypeError("Expected valid private key");if(e.length!==l)throw new Error("Expected 32 bytes of private key");t=M(e)}if(!V(t))throw new Error("Expected private key: 0 < key < n");return t}function G(e){return e instanceof S?(e.assertValidity(),e):S.fromHex(e)}function X(e){if(e instanceof A)return e.assertValidity(),e;try{return A.fromDER(e)}catch(t){return A.fromCompact(e)}}function Y(e){const t=e instanceof Uint8Array,r="string"==typeof e,n=(t||r)&&e.length;return t?n===y||n===p:r?n===2*y||n===2*p:e instanceof S}function Q(e){return M(e.length>d?e.slice(0,d):e)}function ee(e){const t=Q(e),r=$(t,u.n);return te(r<o?t:r)}function te(e){return k(e)}function re(e,r,n){if(null==e)throw new Error(`sign: expected valid message hash, not "${e}"`);const o=L(e),i=Z(r),s=[te(i),ee(o)];if(null!=n){!0===n&&(n=t.utils.randomBytes(d));const e=L(n);if(e.length!==d)throw new Error(`sign: Expected ${d} bytes of extra data`);s.push(e)}return{seed:O(...s),m:Q(o),d:i}}function ne(e,t){const{sig:r,recovery:n}=e,{der:o,recovered:i}=Object.assign({canonical:!0,der:!0},t),s=o?r.toDERRawBytes():r.toCompactRawBytes();return i?[s,n]:s}t.getPublicKey=function(e,t=!1){return S.fromPrivateKey(e).toRawBytes(t)},t.recoverPublicKey=function(e,t,r,n=!1){return S.fromSignature(e,t,r).toRawBytes(n)},t.getSharedSecret=function(e,t,r=!1){if(Y(e))throw new TypeError("getSharedSecret: first arg must be private key");if(!Y(t))throw new TypeError("getSharedSecret: second arg must be public key");const n=G(t);return n.assertValidity(),n.multiply(Z(e)).toRawBytes(r)},t.sign=async function(e,t,r={}){const{seed:n,m:o,d:i}=re(e,t,r.extraEntropy),s=new F(32,l);let a;for(await s.reseed(n);!(a=J(await s.generate(),o,i,r.canonical));)await s.reseed();return ne(a,r)},t.signSync=function(e,t,r={}){const{seed:n,m:o,d:i}=re(e,t,r.extraEntropy),s=new F(32,l);let a;for(s.reseedSync(n);!(a=J(s.generateSync(),o,i,r.canonical));)s.reseedSync();return ne(a,r)};const oe={strict:!0};function ie(e){return $(M(e),u.n)}t.verify=function(e,t,r,n=oe){let o;try{o=X(e),t=L(t)}catch(e){return!1}const{r:i,s}=o;if(n.strict&&o.hasHighS())return!1;const a=q(t);let c;try{c=G(r)}catch(e){return!1}const{n:h}=u,f=D(s,h),d=$(a*f,h),l=$(i*f,h),y=S.BASE.multiplyAndAddUnsafe(c,d,l);return!!y&&$(y.x,h)===i};class se{constructor(e,t){this.r=e,this.s=t,this.assertValidity()}static fromHex(e){const t=L(e);if(64!==t.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${t.length}`);const r=M(t.subarray(0,32)),n=M(t.subarray(32,64));return new se(r,n)}assertValidity(){const{r:e,s:t}=this;if(!W(e)||!V(t))throw new Error("Invalid signature")}toHex(){return C(this.r)+C(this.s)}toRawBytes(){return U(this.toHex())}}class ae{constructor(e,r,n=t.utils.randomBytes()){if(null==e)throw new TypeError(`sign: Expected valid message, not "${e}"`);this.m=L(e);const{x:o,scalar:i}=this.getScalar(Z(r));if(this.px=o,this.d=i,this.rand=L(n),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(e){const t=S.fromPrivateKey(e),r=t.hasEvenY()?e:u.n-e;return{point:t,scalar:r,x:t.toRawX()}}initNonce(e,t){return k(e^M(t))}finalizeNonce(e){const t=$(M(e),u.n);if(t===o)throw new Error("sign: Creation of signature failed. k is zero");const{point:r,x:n,scalar:i}=this.getScalar(t);return{R:r,rx:n,k:i}}finalizeSig(e,t,r,n){return new se(e.x,$(t+r*n,u.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:e,d:r,px:n,rand:o}=this,i=t.utils.taggedHash,s=this.initNonce(r,await i(le.aux,o)),{R:a,rx:c,k:u}=this.finalizeNonce(await i(le.nonce,s,n,e)),h=ie(await i(le.challenge,c,n,e)),f=this.finalizeSig(a,u,h,r);return await he(f,e,n)||this.error(),f}calcSync(){const{m:e,d:r,px:n,rand:o}=this,i=t.utils.taggedHashSync,s=this.initNonce(r,i(le.aux,o)),{R:a,rx:c,k:u}=this.finalizeNonce(i(le.nonce,s,n,e)),h=ie(i(le.challenge,c,n,e)),f=this.finalizeSig(a,u,h,r);return fe(f,e,n)||this.error(),f}}function ce(e,t,r){const n=e instanceof se,o=n?e:se.fromHex(e);return n&&o.assertValidity(),{...o,m:L(t),P:G(r)}}function ue(e,t,r,n){const o=S.BASE.multiplyAndAddUnsafe(t,Z(r),$(-n,u.n));return!(!o||!o.hasEvenY()||o.x!==e)}async function he(e,r,n){try{const{r:o,s:i,m:s,P:a}=ce(e,r,n),c=ie(await t.utils.taggedHash(le.challenge,k(o),a.toRawX(),s));return ue(o,a,i,c)}catch(e){return!1}}function fe(e,r,n){try{const{r:o,s:i,m:s,P:a}=ce(e,r,n),c=ie(t.utils.taggedHashSync(le.challenge,k(o),a.toRawX(),s));return ue(o,a,i,c)}catch(e){if(e instanceof b)throw e;return!1}}t.schnorr={Signature:se,getPublicKey:function(e){return S.fromPrivateKey(e).toRawX()},sign:async function(e,t,r){return new ae(e,t,r).calc()},verify:he,signSync:function(e,t,r){return new ae(e,t,r).calcSync()},verifySync:fe},S.BASE._setWindowSize(8);const de={node:n,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},le={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},ye={};t.utils={bytesToHex:T,hexToBytes:U,concatBytes:O,mod:$,invert:D,isValidPrivateKey(e){try{return Z(e),!0}catch(e){return!1}},_bigintTo32Bytes:k,_normalizePrivateKey:Z,hashToPrivateKey:e=>{e=L(e);const t=l+8;if(e.length<t||e.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");return k($(M(e),u.n-i)+i)},randomBytes:(e=32)=>{if(de.web)return de.web.getRandomValues(new Uint8Array(e));if(de.node){const{randomBytes:t}=de.node;return Uint8Array.from(t(e))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>t.utils.hashToPrivateKey(t.utils.randomBytes(l+8)),precompute(e=8,t=S.BASE){const r=t===S.BASE?t:new S(t.x,t.y);return r._setWindowSize(e),r.multiply(a),r},sha256:async(...e)=>{if(de.web){const t=await de.web.subtle.digest("SHA-256",O(...e));return new Uint8Array(t)}if(de.node){const{createHash:t}=de.node,r=t("sha256");return e.forEach((e=>r.update(e))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(e,...t)=>{if(de.web){const r=await de.web.subtle.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=O(...t),o=await de.web.subtle.sign("HMAC",r,n);return new Uint8Array(o)}if(de.node){const{createHmac:r}=de.node,n=r("sha256",e);return t.forEach((e=>n.update(e))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(e,...r)=>{let n=ye[e];if(void 0===n){const r=await t.utils.sha256(Uint8Array.from(e,(e=>e.charCodeAt(0))));n=O(r,r),ye[e]=n}return t.utils.sha256(n,...r)},taggedHashSync:(e,...t)=>{if("function"!=typeof z)throw new b("sha256Sync is undefined, you need to set it");let r=ye[e];if(void 0===r){const t=z(Uint8Array.from(e,(e=>e.charCodeAt(0))));r=O(t,t),ye[e]=r}return z(r,...t)},_JacobianPoint:m},Object.defineProperties(t.utils,{sha256Sync:{configurable:!1,get:()=>z,set(e){z||(z=e)}},hmacSha256Sync:{configurable:!1,get:()=>K,set(e){K||(K=e)}}})},5921:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.decode=t.encode=t.unescape=t.escape=t.pad=void 0;const n=r(7526);function o(e){return`${e}${"=".repeat(4-(e.length%4||4))}`}function i(e){return e.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function s(e){return o(e).replace(/-/g,"+").replace(/_/g,"/")}t.pad=o,t.escape=i,t.unescape=s,t.encode=function(e){return i((0,n.fromByteArray)((new TextEncoder).encode(e)))},t.decode=function(e){return(new TextDecoder).decode((0,n.toByteArray)(o(s(e))))}},1161:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.cryptoClients=t.SECP256K1Client=void 0;const n=r(2485);Object.defineProperty(t,"SECP256K1Client",{enumerable:!0,get:function(){return n.SECP256K1Client}});const o={ES256K:n.SECP256K1Client};t.cryptoClients=o},2485:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.SECP256K1Client=void 0;const n=r(9615),o=r(2623),i=r(9598),s=r(6216),a=r(8886),c=r(9175);i.utils.hmacSha256Sync=(e,...t)=>{const r=n.hmac.create(o.sha256,e);return t.forEach((e=>r.update(e))),r.digest()};class u{static derivePublicKey(e,t=!0){return 66===e.length&&(e=e.slice(0,64)),e.length<64&&(e=e.padStart(64,"0")),(0,c.bytesToHex)(i.getPublicKey(e,t))}static signHash(e,t,r="jose"){if(!e||!t)throw new a.MissingParametersError("a signing input hash and private key are all required");const n=i.signSync(e,t.slice(0,64),{der:!0,canonical:!1});if("der"===r)return(0,c.bytesToHex)(n);if("jose"===r)return(0,s.derToJose)(n,"ES256");throw Error("Invalid signature format")}static loadSignature(e){return(0,s.joseToDer)(e,"ES256")}static verifyHash(e,t,r){if(!e||!t||!r)throw new a.MissingParametersError("a signing input hash, der signature, and public key are all required");return i.verify(t,e,r,{strict:!1})}}t.SECP256K1Client=u,u.algorithmName="ES256K"},7990:function(e,t,r){var n=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(o,i){function s(e){try{c(n.next(e))}catch(e){i(e)}}function a(e){try{c(n.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(s,a)}c((n=n.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.hashSha256Async=t.hashSha256=void 0;const o=r(2623);function i(e){return(0,o.sha256)(e)}t.hashSha256=i,t.hashSha256Async=function(e){return n(this,void 0,void 0,(function*(){try{if("undefined"!=typeof crypto&&void 0!==crypto.subtle){const t="string"==typeof e?(new TextEncoder).encode(e):e,r=yield crypto.subtle.digest("SHA-256",t);return new Uint8Array(r)}{const t=r(7870);if(!t.createHash)throw new Error("`crypto` module does not contain `createHash`");return Promise.resolve(t.createHash("sha256").update(e).digest())}}catch(t){return console.log(t),console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'),Promise.resolve(i(e))}}))}},1827:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.decodeToken=void 0;const n=r(5921);t.decodeToken=function(e){if("string"==typeof e){const t=e.split(".");return{header:JSON.parse(n.decode(t[0])),payload:JSON.parse(n.decode(t[1])),signature:t[2]}}if("object"==typeof e){if("string"!=typeof e.payload)throw new Error("Expected token payload to be a base64 or json string");let t=e.payload;"{"!==e.payload[0]&&(t=n.decode(t));const r=[];return e.header.map((e=>{const t=JSON.parse(n.decode(e));r.push(t)})),{header:r,payload:JSON.parse(t),signature:e.signature}}}},6216:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.joseToDer=t.derToJose=void 0;const n=r(7526),o=r(5921);function i(e){return(e/8|0)+(e%8==0?0:1)}const s={ES256:i(256),ES384:i(384),ES512:i(521)};function a(e){const t=s[e];if(t)return t;throw new Error(`Unknown algorithm "${e}"`)}const c=128;function u(e){if(e instanceof Uint8Array)return e;if("string"==typeof e)return(0,n.toByteArray)((0,o.pad)(e));throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array")}function h(e,t,r){let n=0;for(;t+n<r&&0===e[t+n];)++n;return e[t+n]>=c&&--n,n}t.derToJose=function(e,t){const r=u(e),i=a(t),s=i+1,c=r.length;let h=0;if(48!==r[h++])throw new Error('Could not find expected "seq"');let f=r[h++];if(129===f&&(f=r[h++]),c-h<f)throw new Error(`"seq" specified length of "${f}", only "${c-h}" remaining`);if(2!==r[h++])throw new Error('Could not find expected "int" for "r"');const d=r[h++];if(c-h-2<d)throw new Error(`"r" specified length of "${d}", only "${c-h-2}" available`);if(s<d)throw new Error(`"r" specified length of "${d}", max of "${s}" is acceptable`);const l=h;if(h+=d,2!==r[h++])throw new Error('Could not find expected "int" for "s"');const y=r[h++];if(c-h!==y)throw new Error(`"s" specified length of "${y}", expected "${c-h}"`);if(s<y)throw new Error(`"s" specified length of "${y}", max of "${s}" is acceptable`);const p=h;if(h+=y,h!==c)throw new Error(`Expected to consume entire array, but "${c-h}" bytes remain`);const g=i-d,w=i-y,b=new Uint8Array(g+d+w+y);for(h=0;h<g;++h)b[h]=0;b.set(r.subarray(l+Math.max(-g,0),l+d),h),h=i;for(const e=h;h<e+w;++h)b[h]=0;return b.set(r.subarray(p+Math.max(-w,0),p+y),h),(0,o.escape)((0,n.fromByteArray)(b))},t.joseToDer=function(e,t){e=u(e);const r=a(t),n=e.length;if(n!==2*r)throw new TypeError(`"${t}" signatures must be "${2*r}" bytes, saw "${n}"`);const o=h(e,0,r),i=h(e,r,e.length),s=r-o,f=r-i,d=2+s+1+1+f,l=d<c,y=new Uint8Array((l?2:3)+d);let p=0;return y[p++]=48,l?y[p++]=d:(y[p++]=129,y[p++]=255&d),y[p++]=2,y[p++]=s,o<0?(y[p++]=0,y.set(e.subarray(0,r),p),p+=r):(y.set(e.subarray(o,r),p),p+=r-o),y[p++]=2,y[p++]=f,i<0?(y[p++]=0,y.set(e.subarray(r),p)):y.set(e.subarray(r+i),p),y}},8886:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidTokenError=t.MissingParametersError=void 0;class r extends Error{constructor(e){super(),this.name="MissingParametersError",this.message=e||""}}t.MissingParametersError=r;class n extends Error{constructor(e){super(),this.name="InvalidTokenError",this.message=e||""}}t.InvalidTokenError=n},9057:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),o(r(675),t),o(r(2695),t),o(r(1827),t),o(r(8886),t),o(r(1161),t)},675:function(e,t,r){var n=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(o,i){function s(e){try{c(n.next(e))}catch(e){i(e)}}function a(e){try{c(n.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(s,a)}c((n=n.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.TokenSigner=t.createUnsecuredToken=void 0;const o=r(5921),i=r(1161),s=r(8886),a=r(7990);function c(e,t){const r=[],n=o.encode(JSON.stringify(t));r.push(n);const i=o.encode(JSON.stringify(e));return r.push(i),r.join(".")}t.createUnsecuredToken=function(e){return c(e,{typ:"JWT",alg:"none"})+"."},t.TokenSigner=class{constructor(e,t){if(!e||!t)throw new s.MissingParametersError("a signing algorithm and private key are required");if("string"!=typeof e)throw new Error("signing algorithm parameter must be a string");if(e=e.toUpperCase(),!i.cryptoClients.hasOwnProperty(e))throw new Error("invalid signing algorithm");this.tokenType="JWT",this.cryptoClient=i.cryptoClients[e],this.rawPrivateKey=t}header(e={}){const t={typ:this.tokenType,alg:this.cryptoClient.algorithmName};return Object.assign({},t,e)}sign(e,t=!1,r={}){const n=this.header(r),o=c(e,n),i=(0,a.hashSha256)(o);return this.createWithSignedHash(e,t,n,o,i)}signAsync(e,t=!1,r={}){return n(this,void 0,void 0,(function*(){const n=this.header(r),o=c(e,n),i=yield(0,a.hashSha256Async)(o);return this.createWithSignedHash(e,t,n,o,i)}))}createWithSignedHash(e,t,r,n,i){const s=this.cryptoClient.signHash(i,this.rawPrivateKey);return t?{header:[o.encode(JSON.stringify(r))],payload:JSON.stringify(e),signature:[s]}:[n,s].join(".")}}},2695:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TokenVerifier=void 0;const n=r(5921),o=r(1161),i=r(8886),s=r(7990);t.TokenVerifier=class{constructor(e,t){if(!e||!t)throw new i.MissingParametersError("a signing algorithm and public key are required");if("string"!=typeof e)throw"signing algorithm parameter must be a string";if(e=e.toUpperCase(),!o.cryptoClients.hasOwnProperty(e))throw"invalid signing algorithm";this.tokenType="JWT",this.cryptoClient=o.cryptoClients[e],this.rawPublicKey=t}verify(e){return"string"==typeof e?this.verifyCompact(e,!1):"object"==typeof e&&this.verifyExpanded(e,!1)}verifyAsync(e){return"string"==typeof e?this.verifyCompact(e,!0):"object"==typeof e?this.verifyExpanded(e,!0):Promise.resolve(!1)}verifyCompact(e,t){const r=e.split("."),n=r[0]+"."+r[1],o=e=>{const t=this.cryptoClient.loadSignature(r[2]);return this.cryptoClient.verifyHash(e,t,this.rawPublicKey)};if(t)return(0,s.hashSha256Async)(n).then((e=>o(e)));{const e=(0,s.hashSha256)(n);return o(e)}}verifyExpanded(e,t){const r=[e.header.join("."),n.encode(e.payload)].join(".");let o=!0;const i=t=>(e.signature.map((e=>{const r=this.cryptoClient.loadSignature(e);this.cryptoClient.verifyHash(t,r,this.rawPublicKey)||(o=!1)})),o);if(t)return(0,s.hashSha256Async)(r).then((e=>i(e)));{const e=(0,s.hashSha256)(r);return i(e)}}}},391:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.getAddress=void 0;const i=r(9057),s=r(8012);t.getAddress=async e=>{const t=await(0,s.getProviderOrThrow)(e.getProvider),{purposes:r}=e.payload;if(!r)throw new Error("Address purposes are required");try{const r=(0,i.createUnsecuredToken)(e.payload),n=await t.connect(r);e.onFinish?.(n)}catch(t){console.error("[Connect] Error during address request",t),e.onCancel?.()}},o(r(6910),t)},6910:(e,t)=>{var r,n;Object.defineProperty(t,"__esModule",{value:!0}),t.AddressType=t.AddressPurpose=void 0,(n=t.AddressPurpose||(t.AddressPurpose={})).Ordinals="ordinals",n.Payment="payment",n.Stacks="stacks",(r=t.AddressType||(t.AddressType={})).p2pkh="p2pkh",r.p2sh="p2sh",r.p2wpkh="p2wpkh",r.p2wsh="p2wsh",r.p2tr="p2tr",r.stacks="stacks"},4737:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.callWalletPopup=void 0;const i=r(9057),s=r(8012);t.callWalletPopup=async e=>{const t=await(0,s.getProviderOrThrow)(e.getProvider),{method:r}=e.payload;if(!r)throw new Error("A wallet method is required");const n=(0,i.createUnsecuredToken)(e.payload);try{const r=await t.call(n);e.onFinish?.(r)}catch(t){console.error("[Connect] Error during call request",t),e.onCancel?.()}},o(r(896),t)},896:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0})},9608:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.getCapabilities=void 0;const i=r(9057),s=r(8012),a=(e,t)=>{const r=r=>!(!e[r]||t&&!t.has(r)),n={call:r("call"),connect:r("connect"),signMessage:r("signMessage"),signTransaction:r("signTransaction"),sendBtcTransaction:r("sendBtcTransaction"),createInscription:r("createInscription"),createRepeatInscriptions:r("createRepeatInscriptions"),signMultipleTransactions:r("signMultipleTransactions")};return Object.entries(n).reduce(((e,[t,r])=>r?[...e,t]:e),[])};t.getCapabilities=async e=>{const t=await(0,s.getProviderOrThrow)(e.getProvider),r=(0,i.createUnsecuredToken)(e.payload);if(t.getCapabilities)try{const n=await t.getCapabilities(r);e.onFinish?.(a(t,new Set(n)))}catch(e){console.error("[Connect] Error during capabilities request",e)}try{const r=a(t);e.onFinish?.(r)}catch(t){console.error("[Connect] Error during capabilities request",t),e.onCancel?.()}},o(r(1386),t)},1386:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0})},7904:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),o(r(391),t),o(r(4737),t),o(r(9608),t),o(r(8350),t),o(r(5573),t),o(r(8012),t),o(r(7344),t),o(r(6773),t)},9616:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createInscription=void 0;const n=r(9057),o=r(8012),i=r(5247);t.createInscription=async e=>{const{getProvider:t}=e,r=await(0,o.getProviderOrThrow)(t);(0,i.validateInscriptionPayload)(e.payload);try{const t=(0,n.createUnsecuredToken)(e.payload),o=await r.createInscription(t);e.onFinish?.(o)}catch(t){console.error("[Connect] Error during create inscription",t),e.onCancel?.()}}},2108:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createRepeatInscriptions=void 0;const n=r(8012),o=r(9057),i=r(5247);t.createRepeatInscriptions=async e=>{const{getProvider:t}=e,r=await(0,n.getProviderOrThrow)(t);(0,i.validateInscriptionPayload)(e.payload);try{const t=(0,o.createUnsecuredToken)(e.payload),n=await r.createRepeatInscriptions(t);e.onFinish?.(n)}catch(t){console.error("[Connect] Error during create repeat inscriptions",t),e.onCancel?.()}}},8350:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),o(r(9616),t),o(r(2108),t),o(r(2067),t)},2067:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0})},5247:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.validateInscriptionPayload=void 0,t.validateInscriptionPayload=e=>{const{contentType:t,content:r,payloadType:n,network:o,appFeeAddress:i,appFee:s}=e;if(!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t))throw new Error("Invalid content type detected");if(!r||0===r.length)throw new Error("Empty content not allowed");if(!n||"BASE_64"!==n&&"PLAIN_TEXT"!==n)throw new Error("Empty invalid payloadType specified");if(r.length>("Mainnet"===o.type?4e5:6e4))throw new Error("Content too large");if((i?.length??0)>0&&(s??0)<=0)throw new Error("Invalid combination of app fee address and fee provided")}},5573:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.signMessage=void 0;const i=r(9057),s=r(8012);t.signMessage=async e=>{const t=await(0,s.getProviderOrThrow)(e.getProvider),{address:r,message:n}=e.payload;if(!r)throw new Error("An address is required to sign a message");if(!n)throw new Error("A message to be signed is required");try{const r=(0,i.createUnsecuredToken)(e.payload),n=await t.signMessage(r);e.onFinish?.(n)}catch(t){console.error("[Connect] Error during sign message request",t),e.onCancel?.()}},o(r(8428),t)},8428:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0})},8012:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.getProviderOrThrow=void 0,t.getProviderOrThrow=async function(e){const t=await(e?.())||window.XverseProviders?.BitcoinProvider||window.BitcoinProvider;if(!t)throw new Error("No Bitcoin wallet installed");return t},o(r(265),t)},265:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0})},7344:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var o=Object.getOwnPropertyDescriptor(t,r);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,o)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),o(r(4965),t),o(r(7859),t),o(r(2090),t),o(r(8069),t)},4965:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sendBtcTransaction=void 0;const n=r(9057),o=r(8012);t.sendBtcTransaction=async e=>{const t=await(0,o.getProviderOrThrow)(e.getProvider),{recipients:r,senderAddress:i,network:s,message:a}=e.payload;if(!r||0===r.length)throw new Error("At least one recipient is required");if(r.some((e=>"string"!=typeof e.address||"bigint"!=typeof e.amountSats)))throw new Error("Incorrect recipient format");if(!i)throw new Error("The sender address is required");try{const o={network:s,senderAddress:i,message:a,recipients:r.map((e=>{const{address:t,amountSats:r}=e;return{address:t,amountSats:r.toString()}}))},c=(0,n.createUnsecuredToken)(o),u=await t.sendBtcTransaction(c);e.onFinish?.(u)}catch(t){console.error("[Connect] Error during send BTC transaction request",t),e.onCancel?.()}}},2090:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.signMultipleTransactions=void 0;const n=r(9057),o=r(8012);t.signMultipleTransactions=async e=>{const t=await(0,o.getProviderOrThrow)(e.getProvider),{psbts:r}=e.payload;if(!r||!r.length)throw new Error("psbts array is required");if(r.length>100)throw new Error("psbts array must contain less than 100 psbts");try{const r=(0,n.createUnsecuredToken)(e.payload),o=await t.signMultipleTransactions(r);e.onFinish?.(o)}catch(t){console.error("[Connect] Error during sign Multiple transactions request",t),e.onCancel?.()}}},7859:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.signTransaction=void 0;const n=r(9057),o=r(8012);t.signTransaction=async e=>{const t=await(0,o.getProviderOrThrow)(e.getProvider),{psbtBase64:r,inputsToSign:i}=e.payload;if(!r)throw new Error("A value for psbtBase64 representing the tx hash is required");if(!i)throw new Error("An array specifying the inputs to be signed by the wallet is required");try{const r=(0,n.createUnsecuredToken)(e.payload),o=await t.signTransaction(r);e.onFinish?.(o)}catch(t){console.error("[Connect] Error during sign transaction request",t),e.onCancel?.()}}},8069:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0})},6773:(e,t)=>{var r;Object.defineProperty(t,"__esModule",{value:!0}),t.BitcoinNetworkType=void 0,(r=t.BitcoinNetworkType||(t.BitcoinNetworkType={})).Mainnet="Mainnet",r.Testnet="Testnet"}}]);